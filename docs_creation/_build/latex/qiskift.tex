%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{QiskiFT}
\date{Jul 10, 2021}
\release{1.0.0}
\author{Owen Dugan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


QiskiFT is a package for implementing Quantum Error Correction and Quantum Fault Tolerance in Python using \sphinxhref{https://qiskit.org/}{Qiskit}. It automates much of the process of implementing fault tolerant computation, allowing users to create fault\sphinxhyphen{}tolerant circuits in only a few more lines of code than non\sphinxhyphen{}fault\sphinxhyphen{}tolerant circuits. For example, Deutsch’s Algorithm can be implemented fault\sphinxhyphen{}tolerantly in 15 lines of code.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=800\sphinxpxdimen]{{Deutsch}.png}
\sphinxfigcaption{A non\sphinxhyphen{}fault\sphinxhyphen{}tolerant implementation of Deutsch’s Algorithm.}\label{\detokenize{index:id1}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=800\sphinxpxdimen]{{DeutschFT}.png}
\sphinxfigcaption{A fault\sphinxhyphen{}tolerant implementation of Deutsch’s Algorithm.}\label{\detokenize{index:id2}}\end{sphinxfigure-in-table}\relax
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Below are links to documentation for each of QiskiFT’s modules.


\chapter{QiskiFT API}
\label{\detokenize{API:qiskift-api}}\label{\detokenize{API::doc}}

\section{The BaseFaultTolerance Module}
\label{\detokenize{Base:the-basefaulttolerance-module}}\label{\detokenize{Base::doc}}\phantomsection\label{\detokenize{Base:module-BaseFaultTolerance}}\index{module@\spxentry{module}!BaseFaultTolerance@\spxentry{BaseFaultTolerance}}\index{BaseFaultTolerance@\spxentry{BaseFaultTolerance}!module@\spxentry{module}}
The BaseFaultTolerance module contains base classes for Quantum Error Correction and Quantum Fault Tolerance. 
These classes are generic; they require the user to provide the relevant algorithms when they are initialized.
For specific quantum codes, see the Codes page. Note that only the Steane code is currently implemented.
\index{BaseFaultTolerantMeasurement (class in BaseFaultTolerance)@\spxentry{BaseFaultTolerantMeasurement}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.BaseFaultTolerantMeasurement}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{BaseFaultTolerantMeasurement}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
A class for implementing fault\sphinxhyphen{}tolerant measurement. NOT YET IMPLEMENTED.
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{is\_analysis\_pass}}}] \leavevmode
Check if the pass is an analysis pass.

\item[{\sphinxcode{\sphinxupquote{is\_transformation\_pass}}}] \leavevmode
Check if the pass is a transformation pass.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{name}}()
&
Return the name of the pass.
\\
\hline
\sphinxcode{\sphinxupquote{run}}(dag)
&
Run a pass on the DAGCircuit.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{fulllineitems}

\index{Encoder (class in BaseFaultTolerance)@\spxentry{Encoder}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{Encoder}}}{\emph{\DUrole{n}{encoderCircuit}}, \emph{\DUrole{n}{numAncillas}}}{}
A class for implementing the non\sphinxhyphen{}fault tolerant ecoding of the Steane \(|0\rangle\) state.
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{createEncoderCircuit :}
&
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{createEncoderDag :}
&
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{getEncoderCircuit :}
&
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxstylestrong{getEncoderDag :}
&
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (BaseFaultTolerance.Encoder method)@\spxentry{createEncoderCircuit()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a circuit encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (BaseFaultTolerance.Encoder method)@\spxentry{createEncoderDag()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a DAG encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (BaseFaultTolerance.Encoder method)@\spxentry{getEncoderCircuit()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (BaseFaultTolerance.Encoder method)@\spxentry{getEncoderDag()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ErrorCorrector (class in BaseFaultTolerance)@\spxentry{ErrorCorrector}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.ErrorCorrector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{ErrorCorrector}}}{\emph{\DUrole{n}{syndromeDetector}}, \emph{\DUrole{n}{syndromeCorrector}}}{}
A class for implementing non\sphinxhyphen{}fault tolerant error correction (syndrome detection and correction) for an arbitrary error correction scheme.
This class combines \sphinxcode{\sphinxupquote{SyndromeDetection}} and \sphinxcode{\sphinxupquote{SyndromeCorrection}} into a single class for ease of use.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{syndromeDetector}}] \leavevmode{[}SyndromeDetector{]}
An object representing syndrome detection.

\item[{\sphinxstylestrong{syndromeCorrector}}] \leavevmode{[}SyndromeCorrector{]}
An object representing syndrome correction.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{errorCorrectCircuit :}
&
Implements error correction for the given circuit.
\\
\hline
\sphinxstylestrong{errorCorrecDag :}
&
Implements error correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{errorCorrectCircuit() (BaseFaultTolerance.ErrorCorrector method)@\spxentry{errorCorrectCircuit()}\spxextra{BaseFaultTolerance.ErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.ErrorCorrector.errorCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing fault tolerant error correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{errorCorrectDag() (BaseFaultTolerance.ErrorCorrector method)@\spxentry{errorCorrectDag()}\spxextra{BaseFaultTolerance.ErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.ErrorCorrector.errorCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing non\sphinxhyphen{}fault tolerant error correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The dag for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FaultTolerance (class in BaseFaultTolerance)@\spxentry{FaultTolerance}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{FaultTolerance}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
A Transpiler pass that converts a given quantum computation into an equivalent one with error correction. NOT YET IMPLEMENTED
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{is\_analysis\_pass}}}] \leavevmode
Check if the pass is an analysis pass.

\item[{\sphinxcode{\sphinxupquote{is\_transformation\_pass}}}] \leavevmode
Check if the pass is a transformation pass.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{name}}()
&
Return the name of the pass.
\\
\hline
{\hyperref[\detokenize{Base:BaseFaultTolerance.FaultTolerance.run}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run}}}}}()
&
Run a pass on the DAGCircuit.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\index{run() (BaseFaultTolerance.FaultTolerance method)@\spxentry{run()}\spxextra{BaseFaultTolerance.FaultTolerance method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerance.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
Run a pass on the DAGCircuit. This is implemented by the pass developer.
\begin{description}
\item[{Args:}] \leavevmode
dag (DAGCircuit): the dag on which the pass is run.

\item[{Raises:}] \leavevmode
NotImplementedError: when this is left unimplemented for a pass.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{FaultTolerantEncoder (class in BaseFaultTolerance)@\spxentry{FaultTolerantEncoder}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{FaultTolerantEncoder}}}{\emph{\DUrole{n}{encoder}}, \emph{\DUrole{n}{checkerCircuit}}, \emph{\DUrole{n}{numAncillas}}, \emph{\DUrole{n}{correctVal}}, \emph{\DUrole{n}{numRepeats}}}{}
A class for implementing an fault tolerant ecoding of the \(|0\rangle\) state for an arbitrary quantum code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{encoder}}] \leavevmode{[}Encoder{]}
An Encoder object representing the \(|0\rangle\) state non\sphinxhyphen{}fault tolerant encoding process.

\item[{\sphinxstylestrong{checkerCircuit}}] \leavevmode{[}QuantumCircuit{]}
A circuit for determining whether the \(|0\rangle\) state has been encoded properly.

\item[{\sphinxstylestrong{numAncillas}}] \leavevmode{[}int{]}
The number of ancilla qubits used to check the encoded effect. 
Note: the ancilla qubits must be at the end of the list of qubits for the circuit.

\item[{\sphinxstylestrong{correctVal}}] \leavevmode{[}int{]}
The classical register value corresponding to the correct initialization of the encoded \(|0\rangle\) state.

\item[{\sphinxstylestrong{numRepeats}}] \leavevmode{[}int{]}
The number of times to attempt to create the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{createEncoderCircuit :}
&
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{createEncoderDag :}
&
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{getEncoderCircuit :}
&
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxstylestrong{getEncoderDag :}
&
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{createEncoderCircuit()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a circuit fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{createEncoderDag()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a DAG fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{getEncoderCircuit()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{getEncoderDag()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FaultTolerantGates (class in BaseFaultTolerance)@\spxentry{FaultTolerantGates}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantGates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{FaultTolerantGates}}}{\emph{\DUrole{n}{gatesToCircuit}}}{}
A class for implementing fault tolerant gates for an arbitrary quantum error correction code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{gatesToCircuit}}] \leavevmode{[}map(str, (QuantumCircuit, int)){]}
A map representing conversions between gates and circuits implementing fault tolerant versions of those gates. 
The keys of the map are the QASM label for the gate in question, given by \sphinxcode{\sphinxupquote{gate.qasm()}}.
The outputs of the map are tuples of the form \sphinxcode{\sphinxupquote{(circuit, numAncillas)}}, where \sphinxcode{\sphinxupquote{circuit}} is a fault\sphinxhyphen{}tolerant implementation of a gate and \sphinxcode{\sphinxupquote{numAncillas}} is the number of ancillas qubits used in the fault\sphinxhyphen{}tolerant implementation of the gate.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{addGateCircuit :}
&
Adds a fault tolerant gate to the given circuit.
\\
\hline
\sphinxstylestrong{addGateDag :}
&
Adds a fault tolerant gate to the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{addGateCircuit() (BaseFaultTolerance.FaultTolerantGates method)@\spxentry{addGateCircuit()}\spxextra{BaseFaultTolerance.FaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantGates.addGateCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds the specified number of fault tolerant implementations of a quantum gate to the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{addGateDag() (BaseFaultTolerance.FaultTolerantGates method)@\spxentry{addGateDag()}\spxextra{BaseFaultTolerance.FaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantGates.addGateDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds the specified number of fault tolerant implementations of a quantum gate to the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The dag on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SyndromeCorrector (class in BaseFaultTolerance)@\spxentry{SyndromeCorrector}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeCorrector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{SyndromeCorrector}}}{\emph{\DUrole{n}{correctorCircuit}}}{}
A class for implementing fault tolerant syndrome correction for an arbitrary error correction scheme.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{correctorCircuit}}] \leavevmode{[}QuantumCircuit{]}
A Quantum Circuit implementing fault tolerant syndrome correction for a single qubit.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{syndromeCorrectCircuit :}
&
Implements syndrome correction for the given circuit.
\\
\hline
\sphinxstylestrong{syndromeCorrectDag :}
&
Implements syndrome correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeCorrectCircuit() (BaseFaultTolerance.SyndromeCorrector method)@\spxentry{syndromeCorrectCircuit()}\spxextra{BaseFaultTolerance.SyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeCorrector.syndromeCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeCorrectDag() (BaseFaultTolerance.SyndromeCorrector method)@\spxentry{syndromeCorrectDag()}\spxextra{BaseFaultTolerance.SyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeCorrector.syndromeCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The dag for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SyndromeDetector (class in BaseFaultTolerance)@\spxentry{SyndromeDetector}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeDetector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{SyndromeDetector}}}{\emph{\DUrole{n}{detectorCircuit}}, \emph{\DUrole{n}{numAncillas}}}{}
A class for implementing non\sphinxhyphen{}fault tolerant syndrome detection for an arbitrary error correction scheme.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{detectorCircuit}}] \leavevmode{[}QuantumCircuit{]}
A Quantum Circuit implementing non\sphinxhyphen{}fault tolerant syndrome detection.

\item[{\sphinxstylestrong{numAncillas}}] \leavevmode{[}int{]}
The number of ancilla qubits used in the syndrome detection.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{syndromeDetectCircuit :}
&
Implements syndrome detection for the given circuit.
\\
\hline
\sphinxstylestrong{syndromeDetectDag :}
&
Implements syndrome detection for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeDetectCircuit() (BaseFaultTolerance.SyndromeDetector method)@\spxentry{syndromeDetectCircuit()}\spxextra{BaseFaultTolerance.SyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeDetector.syndromeDetectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeDetectDag() (BaseFaultTolerance.SyndromeDetector method)@\spxentry{syndromeDetectDag()}\spxextra{BaseFaultTolerance.SyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeDetector.syndromeDetectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The DAG for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{The Steane Module}
\label{\detokenize{Steane:the-steane-module}}\label{\detokenize{Steane::doc}}\phantomsection\label{\detokenize{Steane:module-Steane}}\index{module@\spxentry{module}!Steane@\spxentry{Steane}}\index{Steane@\spxentry{Steane}!module@\spxentry{module}}
The Steane Module implements Quantum Error Correction and Quantum Fault Tolerance using the Steane 7\sphinxhyphen{}qubit code. 
The 7\sphinxhyphen{}qubit code encodes the state \(|\phi\rangle\) as 
\begin{equation*}
\begin{split}|\tilde{\phi}\rangle = (1+X_0X_4X_5X_6)(1+X_1X_3X_5X_6)(1+X_2X_3X_4X_6)|\phi\rangle.\end{split}
\end{equation*}
For Syndrome Detection, the Steane code measures 6 operators:
\begin{equation*}
\begin{split}M_a = X_0X_4X_5X_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}M_b = X_1X_3X_5X_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}M_c = X_2X_3X_4X_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}N_a = Z_0Z_4Z_5Z_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}N_b = Z_1Z_3Z_5Z_6,\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}N_c = Z_2Z_3Z_4Z_6.\end{split}
\end{equation*}
More details about each aspect of the Steane code are provided below.
\index{SteaneEncoder (class in Steane)@\spxentry{SteaneEncoder}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneEncoder}}}
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.Encoder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.Encoder}}}}}

A class for implementing non\sphinxhyphen{}fault tolerant preparation of the Steane \(|0\rangle\) state.
As described at the top of this page, the \(|0\rangle\) state is encoded as 
\begin{equation*}
\begin{split}|\tilde{0}\rangle = (1+X_0X_4X_5X_6)(1+X_1X_3X_5X_6)(1+X_2X_3X_4X_6)|0\rangle.\end{split}
\end{equation*}
The circuit representation of the initialization process is:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{SteaneEncoding}.png}
\end{figure}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{createEncoderCircuit :}
&
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{createEncoderDag :}
&
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{getEncoderCircuit :}
&
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxstylestrong{getEncoderDag :}
&
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (Steane.SteaneEncoder method)@\spxentry{createEncoderCircuit()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a circuit encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (Steane.SteaneEncoder method)@\spxentry{createEncoderDag()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a DAG encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (Steane.SteaneEncoder method)@\spxentry{getEncoderCircuit()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (Steane.SteaneEncoder method)@\spxentry{getEncoderDag()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneErrorCorrector (class in Steane)@\spxentry{SteaneErrorCorrector}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneErrorCorrector}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneErrorCorrector}}}
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.ErrorCorrector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.ErrorCorrector}}}}}

A class for implementing non\sphinxhyphen{}fault tolerant error correction for the Steane Code.
This class combines \sphinxcode{\sphinxupquote{SteaneSyndromeDetection}} and \sphinxcode{\sphinxupquote{SteaneSyndromeCorrection}} into a single class for ease of use.
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{errorCorrectCircuit :}
&
Implements error correction for the given circuit.
\\
\hline
\sphinxstylestrong{errorCorrecDag :}
&
Implements error correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{errorCorrectCircuit() (Steane.SteaneErrorCorrector method)@\spxentry{errorCorrectCircuit()}\spxextra{Steane.SteaneErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneErrorCorrector.errorCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing fault tolerant error correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{errorCorrectDag() (Steane.SteaneErrorCorrector method)@\spxentry{errorCorrectDag()}\spxextra{Steane.SteaneErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneErrorCorrector.errorCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing non\sphinxhyphen{}fault tolerant error correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The dag for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneFaultTolerantEncoder (class in Steane)@\spxentry{SteaneFaultTolerantEncoder}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneFaultTolerantEncoder}}}{\emph{\DUrole{n}{numRepeats}}}{}
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.FaultTolerantEncoder}}}}}

A class for implementing fault tolerant ecoding of the Steane encoded \(|0\rangle\) state.
NOT FINISHED.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numRepeats}}] \leavevmode{[}int{]}
The number of times to try to create the \(|0\rangle\) state before giving up.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{createEncoderCircuit :}
&
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{createEncoderDag :}
&
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxstylestrong{getEncoderCircuit :}
&
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxstylestrong{getEncoderDag :}
&
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{createEncoderCircuit()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a circuit fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{createEncoderDag()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
Creates a DAG fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{getEncoderCircuit()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{getEncoderDag()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneFaultTolerantGates (class in Steane)@\spxentry{SteaneFaultTolerantGates}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantGates}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneFaultTolerantGates}}}
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.FaultTolerantGates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.FaultTolerantGates}}}}}

A class for implementing fault tolerant gates for the Steane Code.
The current implemented gates are \(X,\) \(H,\) \(S,\) and CNOT. These gates can all be implemented bitwise.
The figures below show the implementations for these four gates.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneX}.png}
\sphinxfigcaption{The fault tolerant X gate.}\label{\detokenize{Steane:id1}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneH}.png}
\sphinxfigcaption{The fault tolerant H gate.}\label{\detokenize{Steane:id2}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneS}.png}
\sphinxfigcaption{The fault tolerant S gate.}\label{\detokenize{Steane:id3}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneCNOT}.png}
\sphinxfigcaption{The fault tolerant CNOT gate.}\label{\detokenize{Steane:id4}}\end{sphinxfigure-in-table}\relax
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{addGateCircuit :}
&
Adds a fault tolerant gate to the given circuit.
\\
\hline
\sphinxstylestrong{addGateDag :}
&
Adds a fault tolerant gate to the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{addGateCircuit() (Steane.SteaneFaultTolerantGates method)@\spxentry{addGateCircuit()}\spxextra{Steane.SteaneFaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantGates.addGateCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds the specified number of fault tolerant implementations of a quantum gate to the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{addGateDag() (Steane.SteaneFaultTolerantGates method)@\spxentry{addGateDag()}\spxextra{Steane.SteaneFaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantGates.addGateDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds the specified number of fault tolerant implementations of a quantum gate to the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The dag on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneSyndromeCorrector (class in Steane)@\spxentry{SteaneSyndromeCorrector}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeCorrector}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneSyndromeCorrector}}}
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.SyndromeCorrector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.SyndromeCorrector}}}}}

A class for implementing fault tolerant syndrome correction for the Steane code.
The circuit representation for Syndrome Correction is shown below:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{SteaneSyndromeCorrection}.png}
\end{figure}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{syndromeCorrectCircuit :}
&
Implements syndrome correction for the given circuit.
\\
\hline
\sphinxstylestrong{syndromeCorrectDag :}
&
Implements syndrome correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeCorrectCircuit() (Steane.SteaneSyndromeCorrector method)@\spxentry{syndromeCorrectCircuit()}\spxextra{Steane.SteaneSyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeCorrector.syndromeCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeCorrectDag() (Steane.SteaneSyndromeCorrector method)@\spxentry{syndromeCorrectDag()}\spxextra{Steane.SteaneSyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeCorrector.syndromeCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The dag for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneSyndromeDetector (class in Steane)@\spxentry{SteaneSyndromeDetector}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeDetector}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneSyndromeDetector}}}
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.SyndromeDetector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.SyndromeDetector}}}}}

A class for implementing non\sphinxhyphen{}fault tolerant syndrome detection for the Steane Code.
Syndrome detection works by measuring six stabilizer operators, \(M_a,\) \(M_b,\) \(M_c,\) \(N_a,\) \(N_b,\) and \(N_c,\) defined at the top of this page.
The circuit representation of the syndrome detection process is:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{SteaneSyndromeDetection}.png}
\end{figure}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{syndromeDetectCircuit :}
&
Implements syndrome detection for the given circuit.
\\
\hline
\sphinxstylestrong{syndromeDetectDag :}
&
Implements syndrome detection for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeDetectCircuit() (Steane.SteaneSyndromeDetector method)@\spxentry{syndromeDetectCircuit()}\spxextra{Steane.SteaneSyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeDetector.syndromeDetectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
The circuit for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeDetectDag() (Steane.SteaneSyndromeDetector method)@\spxentry{syndromeDetectDag()}\spxextra{Steane.SteaneSyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeDetector.syndromeDetectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
The DAG for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{QiskiFT Demonstrations}
\label{\detokenize{Demos:qiskift-demonstrations}}\label{\detokenize{Demos::doc}}
Below are links to several Jupyter notebooks demonstrating QiskiFT’s current functionalities.
\begin{itemize}
\item {} 
\sphinxhref{https://github.com/druidowm/qiskift/blob/main/qiskift/SteaneTestErrorCorrection.ipynb}{This notebook} illustrates the building blocks of the Steane code.

\item {} 
\sphinxhref{https://github.com/druidowm/qiskift/blob/main/qiskift/SteaneTestCircuit.ipynb}{This notebook} illustrates how to use QiskiFT to create a (partially) fault tolerant circuit representation of Deutsch’s Algorithm using the Steane code.

\item {} 
\sphinxhref{https://github.com/druidowm/qiskift/blob/main/qiskift/SteaneTestDag.ipynb}{This notebook} illustrates how to use QiskiFT to create a (partially) fault tolerant Directed Acyclic Graph representation of Deutsch’s Algorithm using the Steane code.

\end{itemize}

This documentation is available as both a \sphinxhref{https://druidowm.github.io/qiskift/}{website} and a \sphinxcode{\sphinxupquote{pdf download}}. The code for this repository can be found \sphinxhref{https://github.com/druidowm/qiskift}{here}.


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{BaseFaultTolerance}\sphinxstyleindexpageref{Base:\detokenize{module-BaseFaultTolerance}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{Steane}\sphinxstyleindexpageref{Steane:\detokenize{module-Steane}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}