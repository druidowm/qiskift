%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{QiskiFT}
\date{May 16, 2021}
\release{1.0.0}
\author{Owen Dugan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
QiskiFT is a package for implementing Quantum Error Correction and Quantum Fault Tolerance in Python using Qiskit. It automates much of the process of implementing fault tolerant computation, allowing users to create fault\sphinxhyphen{}tolerant circuits in only a few more lines of code than non\sphinxhyphen{}fault\sphinxhyphen{}tolerant circuits. For example, Deutsch’s Algorithm can be implemented fault\sphinxhyphen{}tolerantly in 15 lines of code.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=600\sphinxpxdimen]{{Deutsch}.png}
\sphinxfigcaption{A non\sphinxhyphen{}fault\sphinxhyphen{}tolerant implementation of Deutsch’s Algorithm.}\label{\detokenize{index:id1}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=800\sphinxpxdimen]{{DeutschFT}.png}
\sphinxfigcaption{A fault\sphinxhyphen{}tolerant implementation of Deutsch’s Algorithm.}\label{\detokenize{index:id2}}\end{sphinxfigure-in-table}\relax
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{QiskiFT API}
\label{\detokenize{API:qiskift-api}}\label{\detokenize{API::doc}}

\section{The BaseFaultTolerance Module}
\label{\detokenize{Base:the-basefaulttolerance-module}}\label{\detokenize{Base::doc}}\phantomsection\label{\detokenize{Base:module-BaseFaultTolerance}}\index{module@\spxentry{module}!BaseFaultTolerance@\spxentry{BaseFaultTolerance}}\index{BaseFaultTolerance@\spxentry{BaseFaultTolerance}!module@\spxentry{module}}
\sphinxAtStartPar
The BaseFaultTolerance module contains base classes for Quantum Error Correction and Quantum Fault Tolerance. 
These classes are generic; they require the user to provide the relevant algorithms when they are initialized.
For specific quantum codes, see the Codes page. Note that only the Steane code is currently implemented.
\index{BaseFaultTolerantMeasurement (class in BaseFaultTolerance)@\spxentry{BaseFaultTolerantMeasurement}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.BaseFaultTolerantMeasurement}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{BaseFaultTolerantMeasurement}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
A class for implementing fault\sphinxhyphen{}tolerant measurement. NOT YET IMPLEMENTED.
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{is\_analysis\_pass}}}] \leavevmode
\sphinxAtStartPar
Check if the pass is an analysis pass.

\item[{\sphinxcode{\sphinxupquote{is\_transformation\_pass}}}] \leavevmode
\sphinxAtStartPar
Check if the pass is a transformation pass.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{name}}()
&
\sphinxAtStartPar
Return the name of the pass.
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{run}}(dag)
&
\sphinxAtStartPar
Run a pass on the DAGCircuit.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{fulllineitems}

\index{Encoder (class in BaseFaultTolerance)@\spxentry{Encoder}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{Encoder}}}{\emph{\DUrole{n}{encoderCircuit}}, \emph{\DUrole{n}{numAncillas}}}{}
\sphinxAtStartPar
A class for implementing the non\sphinxhyphen{}fault tolerant ecoding of the Steane \(|0\rangle\) state.
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{createEncoderCircuit :}
&
\sphinxAtStartPar
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{createEncoderDag :}
&
\sphinxAtStartPar
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderCircuit :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderDag :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (BaseFaultTolerance.Encoder method)@\spxentry{createEncoderCircuit()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a circuit encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (BaseFaultTolerance.Encoder method)@\spxentry{createEncoderDag()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a DAG encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (BaseFaultTolerance.Encoder method)@\spxentry{getEncoderCircuit()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (BaseFaultTolerance.Encoder method)@\spxentry{getEncoderDag()}\spxextra{BaseFaultTolerance.Encoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.Encoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ErrorCorrector (class in BaseFaultTolerance)@\spxentry{ErrorCorrector}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.ErrorCorrector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{ErrorCorrector}}}{\emph{\DUrole{n}{syndromeDetector}}, \emph{\DUrole{n}{syndromeCorrector}}}{}
\sphinxAtStartPar
A class for implementing non\sphinxhyphen{}fault tolerant error correction (syndrome detection and correction) for an arbitrary error correction scheme.
This class combines \sphinxcode{\sphinxupquote{SyndromeDetection}} and \sphinxcode{\sphinxupquote{SyndromeCorrection}} into a single class for ease of use.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{syndromeDetector}}] \leavevmode{[}SyndromeDetector{]}
\sphinxAtStartPar
An object representing syndrome detection.

\item[{\sphinxstylestrong{syndromeCorrector}}] \leavevmode{[}SyndromeCorrector{]}
\sphinxAtStartPar
An object representing syndrome correction.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{errorCorrectCircuit :}
&
\sphinxAtStartPar
Implements error correction for the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{errorCorrecDag :}
&
\sphinxAtStartPar
Implements error correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{errorCorrectCircuit() (BaseFaultTolerance.ErrorCorrector method)@\spxentry{errorCorrectCircuit()}\spxextra{BaseFaultTolerance.ErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.ErrorCorrector.errorCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing fault tolerant error correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{errorCorrectDag() (BaseFaultTolerance.ErrorCorrector method)@\spxentry{errorCorrectDag()}\spxextra{BaseFaultTolerance.ErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.ErrorCorrector.errorCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing non\sphinxhyphen{}fault tolerant error correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The dag for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FaultTolerance (class in BaseFaultTolerance)@\spxentry{FaultTolerance}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{FaultTolerance}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
A Transpiler pass that converts a given quantum computation into an equivalent one with error correction. NOT YET IMPLEMENTED
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxcode{\sphinxupquote{is\_analysis\_pass}}}] \leavevmode
\sphinxAtStartPar
Check if the pass is an analysis pass.

\item[{\sphinxcode{\sphinxupquote{is\_transformation\_pass}}}] \leavevmode
\sphinxAtStartPar
Check if the pass is a transformation pass.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{name}}()
&
\sphinxAtStartPar
Return the name of the pass.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{Base:BaseFaultTolerance.FaultTolerance.run}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{run}}}}}()
&
\sphinxAtStartPar
Run a pass on the DAGCircuit.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\index{run() (BaseFaultTolerance.FaultTolerance method)@\spxentry{run()}\spxextra{BaseFaultTolerance.FaultTolerance method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerance.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{}
\sphinxAtStartPar
Run a pass on the DAGCircuit. This is implemented by the pass developer.
\begin{description}
\item[{Args:}] \leavevmode
\sphinxAtStartPar
dag (DAGCircuit): the dag on which the pass is run.

\item[{Raises:}] \leavevmode
\sphinxAtStartPar
NotImplementedError: when this is left unimplemented for a pass.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{FaultTolerantEncoder (class in BaseFaultTolerance)@\spxentry{FaultTolerantEncoder}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{FaultTolerantEncoder}}}{\emph{\DUrole{n}{encoder}}, \emph{\DUrole{n}{checkerCircuit}}, \emph{\DUrole{n}{numAncillas}}, \emph{\DUrole{n}{correctVal}}, \emph{\DUrole{n}{numRepeats}}}{}
\sphinxAtStartPar
A class for implementing an fault tolerant ecoding of the \(|0\rangle\) state for an arbitrary quantum code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{encoder}}] \leavevmode{[}Encoder{]}
\sphinxAtStartPar
An Encoder object representing the \(|0\rangle\) state non\sphinxhyphen{}fault tolerant encoding process.

\item[{\sphinxstylestrong{checkerCircuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
A circuit for determining whether the \(|0\rangle\) state has been encoded properly.

\item[{\sphinxstylestrong{numAncillas}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of ancilla qubits used to check the encoded effect. 
Note: the ancilla qubits must be at the end of the list of qubits for the circuit.

\item[{\sphinxstylestrong{correctVal}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The classical register value corresponding to the correct initialization of the encoded \(|0\rangle\) state.

\item[{\sphinxstylestrong{numRepeats}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of times to attempt to create the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{createEncoderCircuit :}
&
\sphinxAtStartPar
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{createEncoderDag :}
&
\sphinxAtStartPar
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderCircuit :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderDag :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{createEncoderCircuit()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a circuit fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{createEncoderDag()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a DAG fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{getEncoderCircuit()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (BaseFaultTolerance.FaultTolerantEncoder method)@\spxentry{getEncoderDag()}\spxextra{BaseFaultTolerance.FaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{FaultTolerantGates (class in BaseFaultTolerance)@\spxentry{FaultTolerantGates}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantGates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{FaultTolerantGates}}}{\emph{\DUrole{n}{gatesToCircuit}}}{}
\sphinxAtStartPar
A class for implementing fault tolerant gates for an arbitrary quantum error correction code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{gatesToCircuit}}] \leavevmode{[}map(str, (QuantumCircuit, int)){]}
\sphinxAtStartPar
A map representing conversions between gates and circuits implementing fault tolerant versions of those gates. 
The keys of the map are the QASM label for the gate in question, given by \sphinxcode{\sphinxupquote{gate.qasm()}}.
The outputs of the map are tuples of the form \sphinxcode{\sphinxupquote{(circuit, numAncillas)}}, where \sphinxcode{\sphinxupquote{circuit}} is a fault\sphinxhyphen{}tolerant implementation of a gate and \sphinxcode{\sphinxupquote{numAncillas}} is the number of ancillas qubits used in the fault\sphinxhyphen{}tolerant implementation of the gate.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{addGateCircuit :}
&
\sphinxAtStartPar
Adds a fault tolerant gate to the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{addGateDag :}
&
\sphinxAtStartPar
Adds a fault tolerant gate to the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{addGateCircuit() (BaseFaultTolerance.FaultTolerantGates method)@\spxentry{addGateCircuit()}\spxextra{BaseFaultTolerance.FaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantGates.addGateCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Adds the specified number of fault tolerant implementations of a quantum gate to the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
\sphinxAtStartPar
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{addGateDag() (BaseFaultTolerance.FaultTolerantGates method)@\spxentry{addGateDag()}\spxextra{BaseFaultTolerance.FaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.FaultTolerantGates.addGateDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Adds the specified number of fault tolerant implementations of a quantum gate to the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The dag on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
\sphinxAtStartPar
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SyndromeCorrector (class in BaseFaultTolerance)@\spxentry{SyndromeCorrector}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeCorrector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{SyndromeCorrector}}}{\emph{\DUrole{n}{correctorCircuit}}}{}
\sphinxAtStartPar
A class for implementing fault tolerant syndrome correction for an arbitrary error correction scheme.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{correctorCircuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
A Quantum Circuit implementing fault tolerant syndrome correction for a single qubit.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{syndromeCorrectCircuit :}
&
\sphinxAtStartPar
Implements syndrome correction for the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{syndromeCorrectDag :}
&
\sphinxAtStartPar
Implements syndrome correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeCorrectCircuit() (BaseFaultTolerance.SyndromeCorrector method)@\spxentry{syndromeCorrectCircuit()}\spxextra{BaseFaultTolerance.SyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeCorrector.syndromeCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
\sphinxAtStartPar
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeCorrectDag() (BaseFaultTolerance.SyndromeCorrector method)@\spxentry{syndromeCorrectDag()}\spxextra{BaseFaultTolerance.SyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeCorrector.syndromeCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
\sphinxAtStartPar
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The dag for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SyndromeDetector (class in BaseFaultTolerance)@\spxentry{SyndromeDetector}\spxextra{class in BaseFaultTolerance}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeDetector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{BaseFaultTolerance.}}\sphinxbfcode{\sphinxupquote{SyndromeDetector}}}{\emph{\DUrole{n}{detectorCircuit}}, \emph{\DUrole{n}{numAncillas}}}{}
\sphinxAtStartPar
A class for implementing non\sphinxhyphen{}fault tolerant syndrome detection for an arbitrary error correction scheme.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{detectorCircuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
A Quantum Circuit implementing non\sphinxhyphen{}fault tolerant syndrome detection.

\item[{\sphinxstylestrong{numAncillas}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of ancilla qubits used in the syndrome detection.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{syndromeDetectCircuit :}
&
\sphinxAtStartPar
Implements syndrome detection for the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{syndromeDetectDag :}
&
\sphinxAtStartPar
Implements syndrome detection for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeDetectCircuit() (BaseFaultTolerance.SyndromeDetector method)@\spxentry{syndromeDetectCircuit()}\spxextra{BaseFaultTolerance.SyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeDetector.syndromeDetectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeDetectDag() (BaseFaultTolerance.SyndromeDetector method)@\spxentry{syndromeDetectDag()}\spxextra{BaseFaultTolerance.SyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Base:BaseFaultTolerance.SyndromeDetector.syndromeDetectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The DAG for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{The Steane Module}
\label{\detokenize{Steane:the-steane-module}}\label{\detokenize{Steane::doc}}\phantomsection\label{\detokenize{Steane:module-Steane}}\index{module@\spxentry{module}!Steane@\spxentry{Steane}}\index{Steane@\spxentry{Steane}!module@\spxentry{module}}
\sphinxAtStartPar
The Steane Module implements Quantum Error Correction and Quantum Fault Tolerance using the Steane 7\sphinxhyphen{}qubit code. 
The 7\sphinxhyphen{}qubit code encodes the state \(|\phi\rangle\) as 
\begin{equation*}
\begin{split}|\tilde{\phi}\rangle = (1+X_0X_4X_5X_6)(1+X_1X_3X_5X_6)(1+X_2X_3X_4X_6)|\phi\rangle.\end{split}
\end{equation*}
For Syndrome Detection, the Steane code measures 6 operators:
\begin{equation*}
\begin{split}M_a = X_0X_4X_5X_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}M_b = X_1X_3X_5X_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}M_c = X_2X_3X_4X_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}N_a = Z_0Z_4Z_5Z_6,\end{split}
\end{equation*}
\begin{equation*}
\begin{split}N_b = Z_1Z_3Z_5Z_6,\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}N_c = Z_2Z_3Z_4Z_6.\end{split}
\end{equation*}
More details about each aspect of the Steane code are provided below.
\index{SteaneEncoder (class in Steane)@\spxentry{SteaneEncoder}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneEncoder}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.Encoder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.Encoder}}}}}

\sphinxAtStartPar
A class for implementing non\sphinxhyphen{}fault tolerant preparation of the Steane \(|0\rangle\) state.
As described at the top of this page, the \(|0\rangle\) state is encoded as 
\begin{equation*}
\begin{split}|\tilde{0}\rangle = (1+X_0X_4X_5X_6)(1+X_1X_3X_5X_6)(1+X_2X_3X_4X_6)|0\rangle.\end{split}
\end{equation*}
The circuit representation of the initialization process is:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{SteaneEncoding}.png}
\end{figure}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{createEncoderCircuit :}
&
\sphinxAtStartPar
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{createEncoderDag :}
&
\sphinxAtStartPar
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderCircuit :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderDag :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (Steane.SteaneEncoder method)@\spxentry{createEncoderCircuit()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a circuit encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (Steane.SteaneEncoder method)@\spxentry{createEncoderDag()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a DAG encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (Steane.SteaneEncoder method)@\spxentry{getEncoderCircuit()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (Steane.SteaneEncoder method)@\spxentry{getEncoderDag()}\spxextra{Steane.SteaneEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneEncoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneErrorCorrector (class in Steane)@\spxentry{SteaneErrorCorrector}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneErrorCorrector}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneErrorCorrector}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.ErrorCorrector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.ErrorCorrector}}}}}

\sphinxAtStartPar
A class for implementing non\sphinxhyphen{}fault tolerant error correction for the Steane Code.
This class combines \sphinxcode{\sphinxupquote{SteaneSyndromeDetection}} and \sphinxcode{\sphinxupquote{SteaneSyndromeCorrection}} into a single class for ease of use.
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{errorCorrectCircuit :}
&
\sphinxAtStartPar
Implements error correction for the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{errorCorrecDag :}
&
\sphinxAtStartPar
Implements error correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{errorCorrectCircuit() (Steane.SteaneErrorCorrector method)@\spxentry{errorCorrectCircuit()}\spxextra{Steane.SteaneErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneErrorCorrector.errorCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing fault tolerant error correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{errorCorrectDag() (Steane.SteaneErrorCorrector method)@\spxentry{errorCorrectDag()}\spxextra{Steane.SteaneErrorCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneErrorCorrector.errorCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{errorCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing non\sphinxhyphen{}fault tolerant error correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The dag for which to perform error correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform error correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform error correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneFaultTolerantEncoder (class in Steane)@\spxentry{SteaneFaultTolerantEncoder}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneFaultTolerantEncoder}}}{\emph{\DUrole{n}{numRepeats}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.FaultTolerantEncoder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.FaultTolerantEncoder}}}}}

\sphinxAtStartPar
A class for implementing fault tolerant ecoding of the Steane encoded \(|0\rangle\) state.
NOT FINISHED.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numRepeats}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of times to try to create the \(|0\rangle\) state before giving up.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{createEncoderCircuit :}
&
\sphinxAtStartPar
Creates a circuit encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{createEncoderDag :}
&
\sphinxAtStartPar
Creates a DAG encoding the \(|0\rangle\) state
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderCircuit :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a circuit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{getEncoderDag :}
&
\sphinxAtStartPar
Adds gates encoding the \(|0\rangle\) state to a DAG
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{createEncoderCircuit() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{createEncoderCircuit()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.createEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderCircuit}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a circuit fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{createEncoderDag() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{createEncoderDag()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.createEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{createEncoderDag}}}{\emph{\DUrole{n}{numQubits}}}{}
\sphinxAtStartPar
Creates a DAG fault\sphinxhyphen{}tolerantly encoding the specified number of qubits to the encoded \(|0\rangle\) state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{numQubits}}] \leavevmode{[}int{]}
\sphinxAtStartPar
The number of qubits to initialize to the encoded \(|0\rangle\) state.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderCircuit() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{getEncoderCircuit()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.getEncoderCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{getEncoderDag() (Steane.SteaneFaultTolerantEncoder method)@\spxentry{getEncoderDag()}\spxextra{Steane.SteaneFaultTolerantEncoder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantEncoder.getEncoderDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getEncoderDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cregs2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas2}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fault\sphinxhyphen{}tolerantly encodes the specified Quantum Registers to the encoded \(|0\rangle\) state for the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The circuit for which to create the encoding.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to encode to the \(|0\rangle\).

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to encode to the \(|0\rangle\), if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to encode to the \(|0\rangle\), if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the encoding process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneFaultTolerantGates (class in Steane)@\spxentry{SteaneFaultTolerantGates}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantGates}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneFaultTolerantGates}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.FaultTolerantGates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.FaultTolerantGates}}}}}

\sphinxAtStartPar
A class for implementing fault tolerant gates for the Steane Code.
The current implemented gates are \(X,\) \(H,\) \(S,\) and CNOT. These gates can all be implemented bitwise.
The figures below show the implementations for these four gates.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneX}.png}
\sphinxfigcaption{The fault tolerant X gate.}\label{\detokenize{Steane:id1}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneH}.png}
\sphinxfigcaption{The fault tolerant H gate.}\label{\detokenize{Steane:id2}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneS}.png}
\sphinxfigcaption{The fault tolerant S gate.}\label{\detokenize{Steane:id3}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{SteaneCNOT}.png}
\sphinxfigcaption{The fault tolerant CNOT gate.}\label{\detokenize{Steane:id4}}\end{sphinxfigure-in-table}\relax
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{addGateCircuit :}
&
\sphinxAtStartPar
Adds a fault tolerant gate to the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{addGateDag :}
&
\sphinxAtStartPar
Adds a fault tolerant gate to the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{addGateCircuit() (Steane.SteaneFaultTolerantGates method)@\spxentry{addGateCircuit()}\spxextra{Steane.SteaneFaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantGates.addGateCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Adds the specified number of fault tolerant implementations of a quantum gate to the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
\sphinxAtStartPar
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{addGateDag() (Steane.SteaneFaultTolerantGates method)@\spxentry{addGateDag()}\spxextra{Steane.SteaneFaultTolerantGates method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneFaultTolerantGates.addGateDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addGateDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{gate}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Adds the specified number of fault tolerant implementations of a quantum gate to the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The dag on which to perform the fault tolerant gate.

\item[{\sphinxstylestrong{gate}}] \leavevmode{[}Gate{]}
\sphinxAtStartPar
The non\sphinxhyphen{}fault tolerant gate for which to implement a fault tolerant version.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(list(QuantumRegister)){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform the fault tolerant gate. Each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} represents the list of quantum registers which correspond to the ith input to the non\sphinxhyphen{}fault tolerant version of the gate in question. Note that each \sphinxcode{\sphinxupquote{qregs{[}i{]}}} must have the same length.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(list(ClassicalRegister)), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}j{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(list(AncillaRegister)), list(list(QuantumRegister)), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(qregs{[}0{]})}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}{[}j{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}j{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneSyndromeCorrector (class in Steane)@\spxentry{SteaneSyndromeCorrector}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeCorrector}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneSyndromeCorrector}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.SyndromeCorrector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.SyndromeCorrector}}}}}

\sphinxAtStartPar
A class for implementing fault tolerant syndrome correction for the Steane code.
The circuit representation for Syndrome Correction is shown below:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{SteaneSyndromeCorrection}.png}
\end{figure}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{syndromeCorrectCircuit :}
&
\sphinxAtStartPar
Implements syndrome correction for the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{syndromeCorrectDag :}
&
\sphinxAtStartPar
Implements syndrome correction for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeCorrectCircuit() (Steane.SteaneSyndromeCorrector method)@\spxentry{syndromeCorrectCircuit()}\spxextra{Steane.SteaneSyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeCorrector.syndromeCorrectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
\sphinxAtStartPar
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeCorrectDag() (Steane.SteaneSyndromeCorrector method)@\spxentry{syndromeCorrectDag()}\spxextra{Steane.SteaneSyndromeCorrector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeCorrector.syndromeCorrectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeCorrectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}}}{}
\sphinxAtStartPar
Creates gates implementing fault tolerant syndrome correction for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The dag for which to perform syndrome correction.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome correction.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister){]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome correction, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome correction process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SteaneSyndromeDetector (class in Steane)@\spxentry{SteaneSyndromeDetector}\spxextra{class in Steane}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeDetector}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Steane.}}\sphinxbfcode{\sphinxupquote{SteaneSyndromeDetector}}}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{Base:BaseFaultTolerance.SyndromeDetector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BaseFaultTolerance.SyndromeDetector}}}}}

\sphinxAtStartPar
A class for implementing non\sphinxhyphen{}fault tolerant syndrome detection for the Steane Code.
Syndrome detection works by measuring six stabilizer operators, \(M_a,\) \(M_b,\) \(M_c,\) \(N_a,\) \(N_b,\) and \(N_c,\) defined at the top of this page.
The circuit representation of the syndrome detection process is:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{SteaneSyndromeDetection}.png}
\end{figure}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{syndromeDetectCircuit :}
&
\sphinxAtStartPar
Implements syndrome detection for the given circuit.
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{syndromeDetectDag :}
&
\sphinxAtStartPar
Implements syndrome detection for the given DAG.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{syndromeDetectCircuit() (Steane.SteaneSyndromeDetector method)@\spxentry{syndromeDetectCircuit()}\spxextra{Steane.SteaneSyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeDetector.syndromeDetectCircuit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectCircuit}}}{\emph{\DUrole{n}{circuit}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given circuit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{circuit}}] \leavevmode{[}QuantumCircuit{]}
\sphinxAtStartPar
The circuit for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}

\index{syndromeDetectDag() (Steane.SteaneSyndromeDetector method)@\spxentry{syndromeDetectDag()}\spxextra{Steane.SteaneSyndromeDetector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Steane:Steane.SteaneSyndromeDetector.syndromeDetectDag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{syndromeDetectDag}}}{\emph{\DUrole{n}{dag}}, \emph{\DUrole{n}{qregs}}, \emph{\DUrole{n}{cregs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ancillas}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Creates gates implementing non\sphinxhyphen{}fault tolerant syndrome detection for the given qubits in the given DAG.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{dag}}] \leavevmode{[}DAGCircuit{]}
\sphinxAtStartPar
The DAG for which to perform syndrome detection.

\item[{\sphinxstylestrong{qregs}}] \leavevmode{[}list(QuantumRegister){]}
\sphinxAtStartPar
The Quantum Registers to on which to perform syndrome detection.

\item[{\sphinxstylestrong{cregs}}] \leavevmode{[}list(ClassicalRegister), Optional{]}
\sphinxAtStartPar
The Classical Registers used to perform syndrome detection, if classical registers are needed. If \sphinxcode{\sphinxupquote{cregs}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{cregs{[}i{]}}} classical register.

\item[{\sphinxstylestrong{ancillas}}] \leavevmode{[}list(AncillaRegister), list(QuantumRegister), Optional{]}
\sphinxAtStartPar
The Ancilla Registers used to perform syndrome detection,, if ancilla registers are needed. If \sphinxcode{\sphinxupquote{ancillas}} is provided, it must satisfy \sphinxcode{\sphinxupquote{len(ancillas) == len(cregs) == len(qregs)}} and the syndrome detection process for the \sphinxcode{\sphinxupquote{qregs{[}i{]}}} quantum register will use the \sphinxcode{\sphinxupquote{ancillas{[}i{]}}} ancilla register.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{BaseFaultTolerance}\sphinxstyleindexpageref{Base:\detokenize{module-BaseFaultTolerance}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{Steane}\sphinxstyleindexpageref{Steane:\detokenize{module-Steane}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}